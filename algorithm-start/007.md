# 数据结构包含（线性结构与非线性结构）

## 线性结构

- 特点：数据存在一对一的关系
- 存储方式：顺序存储（数组）与链式存储（链表）
- 常见的线性结构包含那些：数据，链表，队列，栈

## 非线性结构

- 非线性结构包括: 二维数组，多维数组，广义表，树结构，图结构

## 稀疏数组

### 定义：

-  当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

### 稀疏数组的处理方法是:（N行3列）

- 记录数组一共有几行几列，有多少个不同的值
- 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

### code

```java
// com.company.array.SparseArray
```

## 队列

- 队列是一个有序列表，可以用数组或是链表来实现。
- 遵循先入先出的原则

### 队列实现queue
- 定义header为添加元素
- 定义tail为获取元素

### code

- 单向队列

```java
// this is version one: ArrayQueueVersion1
```
- 环形数组队列：重要的一点是tail与header都需要从0开始，如果是环形，那么tail一定要在0-size之间，因此tail应该是size的倍数

```java
// this is version one: ArrayQueueVersion2
```

## 链表
- 链表是以节点的方式来存储,是链式存储
- 每个节点包含 data 域(存储数据)， next 域:指向下一个节点.
- 链表的各个节点不一定是连续存储.
- 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定.header节点是用来表示链表的头

### 单向连表（insert，select，delete，update），班内学生身高排名
- step one: 直接添加到尾部，不进行排序(addNode)
- step two: 插入到链表中，并进行排序(addNdeByOrder)

### code
```java
// SingleLinkedListDemo
```

### 链表的题目
- 求单链表中有效节点的个数
- 反转单链表
- 逆序打赢节点（1. 先反转，再打印,不推荐 2.使用栈）


### 双向链表
- 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找
- 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点.

```java
// single: 需要删除的节点的上一个节点
// temp.next = temp.next.next;

// double: 找到当前节点
// temp.pro.next = temp.next;
// temp.next.pro = temp.pro;
```

### 单向环形链表
```java
// CircleSingleLinkedList
```

## 栈

- 栈是一个先入后出(FILO-FirstInLastOut)的有序列表。
- 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)
- 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

```java
// ArrayStackDemo
// 7*2*2-5+1-5+3-4, 计算表达式的值
// 初始两个栈，一个数栈，一个操作符栈
// 顺哥index遍历表达式
// 档遍历遇到数字时直接入数栈，但遇到符号时，栈中没有直接入栈，有，比较有先及，如果优先级小于等于栈中的符号，符号栈出站，数字栈也出站，并计算，并将计算结果入数栈，并将当前符号入站，当遍历完后，顺序出站计算并入数栈
// 最终的数盏中的数据就是计算结果
```

### 前缀（波兰表达式），中缀，后缀（逆波兰表达式）表达式

#### 前缀（从右 --> 左)
- 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果
- 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:
- 从右至左扫描，将6、5、4、3压入堆栈
- 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
- 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
- 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

### 中缀表达式
- 中缀表达式就是常见的运算表达式，如(3+4)×5-6
- 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)

### 后缀表达式的计算机求值（从左 -->  右）
- 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果
- 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:
- 从左至右扫描，将3和4压入堆栈；
- 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；将5入栈；接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；将6入栈；最后是-运算符，计算出35-6的值，即29，由此得出最终结果

## 递归
- 略

## 排序算法
- 内存排序
- 插入排序：直接插入排序，希尔排序
- 选择排序：简单排序，堆排序
- 交换排序：快速排序，冒泡排序
- 归并排序
- 基数排序

### 算法的时间复杂度

#### 时间频度

- 一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。
```java
//int sum = 0;
//for(int i=0;i<100;i++){sum = sum+i}, T(n) = n

// 100*(100+1)/2 , T(n) = 1
```
##### 忽略常数项
- 2n+20 和 2n 随着 n 变大，执行曲线无限接近, 20 可以忽略 2) 
- 3n+10 和 3n 随着 n 变大，执行曲线无限接近, 10 可以忽略

##### 忽略低次项
- 2n^2+3n+10 和 2n^2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10 （^平方）
- n^2+5n+20 和 n^2 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20（^平方）

#### 时间复杂度-(空间复杂度，用空间换时间，缓存redis,cache)
- 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅 助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。 记作 T(n)=O( f(n) )，称O( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。
-  T(n) 不同，但时间复杂度可能相同。 如:T(n)=n2+7n+6 与 T(n)=3n2+2n+2 它们的 T(n) 不同，但时间复杂 度相同，都为 O(n2)。

- 计算时间复杂度的方法
  - 用常数1代替运行时间中的所有加法常数 T(n)=n2+7n+6 => T(n)=n2+7n+1
  - 修改后的运行次数函数中，只保留最高阶项 T(n)=n2+7n+1 => T(n) = n2
  - 去除最高阶项的系数 T(n) = n2 => T(n) = n2 => O(n2)

- 常见的时间复杂度: (随着时间的变化，代码执行此处的变化)
  - 常数阶O(1)
  ```java
  int i = 0;
  int j = 10;
  i++;
  j++;
  int sum = i+j;
  ```
  - 对数阶O(log2n)
  
  ```java
  int i = 1;
  while(i < n){ i = i * 2}
  ```
  - 线性阶O(n)
  - 线性对数阶O(nlog2n)
  - 平方阶O(n^2)
  - 立方阶O(n^3)
  - k次方阶O(n^k)
  - 指数阶O(2^n)
  
#### 冒泡排序
- 通过对待排序序列从前向后(从下标较小的元素开始),依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒
- 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排 序写好后，在进行)

#### 选择排序(选择最小的或最大的再前面的位置)
- 选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到 排序的目的。
- 选择排序(select sorting)也是一种简单的排序方法。它的基本思想是:第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2] 交换，...，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，..., 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列

#### 插入排序
- 插入排序(Insertion Sorting)的基本思想是:把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表

#### 希尔排序(缩小版插入排序)
- 插入排序可能存在的问题数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是: {2,3,4,5,6,6}
- {2,3,4,5,5,6}
- {2,3,4,4,5,6}
- {2,3,3,4,5,6}
- {2,2,3,4,5,6}
- {1,2,3,4,5,6}
- 结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.
- 先分组，再使用插入排序

#### 快速排序
- 通过一趟排序将要排序的数据分割成独立的两 部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

#### 归并排序
- 归并排序(MERGE-SORT)是利用归并的思想实现的排序方法，该算法采用经典的分治(divide-and-conquer) 策略(分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修 补"在一起，即分而治之)

#### 基数排序

- 基数排序(radixsort)属于“分配式排序”(distribution sort)，又称“桶子法”(bucket sort)或bin sort，顾 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
- 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
- 基数排序(RadixSort)是桶排序的扩展
- 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的:将整数按位数切割成不同的数字，然后按每个位数分别比较。
- 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列
- 这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤


#### 查找算法
- 插值查找

```java
// 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快
// int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
```


